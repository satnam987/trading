<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <title>Winrate Calculator per Strategie</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      color-scheme: light;
      --bg: #ffffff;
      --text: #182032;
      --muted: #6b7280;
      --surface: #ffffff;
      --border: #e9eef5;
      --primary: #3b82f6;
      --primary-600: #2563eb;
      --danger: #ef4444;
      --secondary: #cfd6e2;
      --success: #22c55e;
      --shadow: 0 10px 30px rgba(18, 26, 52, 0.06);
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #0b1020;
        --text: #e6e7eb;
        --muted: #9aa1ac;
        --surface: #12172a;
        --border: #232a3d;
        --primary: #3b82f6;
        --primary-600: #2563eb;
        --danger: #ef4444;
        --secondary: #94a3b8;
        --success: #22c55e;
        --shadow: 0 12px 32px rgba(0,0,0,0.35);
      }
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin: 0;
      color: var(--text);
      background: var(--bg);
      padding: 32px 20px 40px;
      position: relative;
    }

    body::before { content: ''; display: none; }

    .card {
      max-width: 1200px;
      margin: 0 auto;
      padding: 28px;
      border: 1px solid var(--border);
      border-radius: 20px;
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.0)) , var(--surface);
      box-shadow: var(--shadow);
      position: relative;
      z-index: 1;
      animation: floatUp .6s ease both;
    }

    h1 {
      font-size: 1.8rem;
      margin: 0 0 18px;
      letter-spacing: 0.2px;
    }

    form {
      display: flex;
      gap: 12px;
      margin-bottom: 18px;
      flex-wrap: wrap;
      align-items: center;
    }

    input[type="text"] {
      flex: 1 1 280px;
      padding: 10px 12px;
      font-size: 1rem;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: var(--surface);
      color: var(--text);
      outline: none;
      transition: border-color .2s, box-shadow .2s;
    }
    input[type="text"]:focus {
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.25);
    }

    button, input[type="number"] { font-size: 0.95rem; }

    button {
      padding: 10px 14px;
      cursor: pointer;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.0));
      color: var(--text);
      box-shadow: 0 2px 0 rgba(0,0,0,0.05);
      transition: transform .12s ease, background .25s, color .25s, border-color .25s, box-shadow .25s, filter .25s;
    }
    button:hover { transform: translateY(-1px); filter: brightness(1.05); box-shadow: 0 6px 16px rgba(17,24,39,0.08); }
    button:active { transform: translateY(0); }
    button:focus-visible { outline: none; box-shadow: 0 0 0 3px rgba(37,99,235,0.35); }

    .primary { background: linear-gradient(90deg, var(--primary), #60a5fa); color: #fff; border-color: var(--primary-600); }
    .primary:hover { filter: brightness(1.06); }

    .secondary { background: linear-gradient(90deg, var(--secondary), #b5becf); color: #111827; border-color: var(--secondary); }
    .secondary:hover { filter: brightness(1.05); }

    .danger { background: linear-gradient(90deg, var(--danger), #f87171); color: #fff; border-color: var(--danger); }
    .danger:hover { filter: brightness(1.05); }

    .small { padding: 8px 10px; }

    .muted { color: var(--muted); font-size: 0.95rem; }

    .table-wrap {
      overflow: auto;
      border-radius: 16px;
      border: 1px solid var(--border);
      background: var(--surface);
      box-shadow: var(--shadow);
      animation: floatUp .6s ease .05s both;
    }

    table { width: 100%; border-collapse: collapse; min-width: 720px; }
    th, td { padding: 12px 14px; border-bottom: 1px solid var(--border); text-align: left; }
    thead th { position: sticky; top: 0; z-index: 1; background: linear-gradient(180deg, rgba(0,0,0,0.02), transparent); font-weight: 600; backdrop-filter: saturate(120%) blur(2px); }
    tbody tr { transition: background-color .18s ease, transform .18s ease; animation: rowIn .45s ease both; }
    tbody tr:hover { background: rgba(59,130,246,0.04); transform: translateY(-1px); }
    tbody tr:nth-child(even) { background: rgba(0,0,0,0.02); }
    tfoot td { font-weight: 700; background: linear-gradient(180deg, transparent, rgba(0,0,0,0.04)); }

    .num { text-align: right; }
    .actions { display: flex; gap: 6px; flex-wrap: wrap; justify-content: flex-start; }

    input[type="number"] {
      width: 110px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--surface);
      color: var(--text);
      outline: none;
      transition: border-color .2s, box-shadow .2s;
    }
    input[type="number"]:focus {
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(37,99,235,0.25);
    }

    select, input[type="date"] {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--surface);
      color: var(--text);
      outline: none;
      transition: border-color .2s, box-shadow .2s;
    }
    select:focus, input[type="date"]:focus {
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(37,99,235,0.25);
    }

    .section-title {
      margin: 18px 2px 10px;
      font-size: 1.05rem;
      font-weight: 600;
      color: var(--muted);
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin: 10px 0 18px;
      align-items: center;
    }
    .toolbar .spacer { flex: 1 1 auto; }

    .import-pane {
      display: none;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--surface);
      box-shadow: var(--shadow);
      padding: 12px;
      margin: 10px 0 18px;
    }
    .import-pane.open { display: block; }
    .import-pane textarea {
      width: 100%;
      min-height: 140px;
      resize: vertical;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: var(--surface);
      color: var(--text);
      outline: none;
      transition: border-color .2s, box-shadow .2s;
    }
    .import-pane textarea:focus {
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(37,99,235,0.25);
    }

    .chart-wrap {
      border: 1px solid var(--border);
      border-radius: 16px;
      background: var(--surface);
      box-shadow: var(--shadow);
      padding: 12px;
      overflow: hidden;
    }
    .chart-wrap canvas { display: block; width: 100%; height: 320px; }

    @media (max-width: 640px) {
      .hide-sm { display: none; }
      input[type="number"] { width: 92px; }
      .small { padding: 6px 8px; }
    }

    @keyframes floatUp {
      from { opacity: 0; transform: translateY(12px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes rowIn {
      from { opacity: 0; transform: translateY(6px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes bgDrift {
      0% { transform: translate3d(0,0,0) scale(1); }
      50% { transform: translate3d(0,6px,0) scale(1.02); }
      100% { transform: translate3d(0,0,0) scale(1); }
    }

    @media (prefers-reduced-motion: reduce) {
      * { animation: none !important; transition: none !important; }
    }
  </style>
</head>
<body>
  <div class="card">
    <h1>Winrate Calculator per Strategie</h1>

    <form id="addForm" autocomplete="off">
      <input id="strategyName" type="text" placeholder="Strategienaam" required />
      <button type="submit" class="primary">Strategie toevoegen</button>
      <span class="muted">Voeg een strategie toe en vul wins/losses in of gebruik de + knoppen.</span>
    </form>

    <div class="toolbar" role="group" aria-label="Export / Import">
      <button id="btnExportJson" class="secondary">Exporteer JSON</button>
      <button id="btnExportCsv" class="secondary">Exporteer CSV</button>
      <button id="btnToggleImport" class="secondary">Plak JSON om te importeren</button>
      <span class="spacer"></span>
      <button id="btnEmail" class="primary">Verstuur naar e-mail</button>
    </div>

    <div id="importPane" class="import-pane" aria-label="JSON import">
      <div class="muted" style="margin-bottom:8px">Plak hier je JSON-backup of array met strategieÃ«n en klik op Importeren.</div>
      <textarea id="importText" placeholder='{"version":2, "strategies":[], "trades":[], "pairs":["EURUSD"]}'></textarea>
      <div style="display:flex; gap:8px; margin-top:10px">
        <button id="btnImportText" class="primary">Importeren</button>
        <button id="btnCancelImport" class="secondary">Sluiten</button>
      </div>
    </div>

    <div class="table-wrap" role="region" aria-label="Winrate tabel" tabindex="0">
      <table aria-label="Winrate tabel">
        <thead>
          <tr>
            <th>Strategie</th>
            <th class="num">Wins</th>
            <th class="num">Losses</th>
            <th class="num hide-sm">Totaal</th>
            <th class="num">Winrate</th>
            <th>Pair</th>
            <th>Richting</th>
            <th>Datum</th>
            <th>Acties</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
        <tfoot>
          <tr>
            <td>Totaal</td>
            <td class="num" id="totalWins">0</td>
            <td class="num" id="totalLosses">0</td>
            <td class="num hide-sm" id="totalTrades">0</td>
            <td class="num" id="totalWinrate">-</td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
        </tfoot>
      </table>
    </div>

    <div class="section-title">Trades</div>
    <div class="table-wrap" role="region" aria-label="Trade log" tabindex="0">
      <table aria-label="Trade log">
        <thead>
          <tr>
            <th>Datum</th>
            <th>Dag</th>
            <th>Pair</th>
            <th>Richting</th>
            <th>Strategie</th>
            <th class="num">Resultaat</th>
            <th>Acties</th>
          </tr>
        </thead>
        <tbody id="tradesTbody"></tbody>
      </table>
    </div>

    <div class="section-title">Trend</div>
    <div class="chart-wrap">
      <canvas id="trendChart" width="1200" height="320" aria-label="Cumulatieve win/verlies trend" role="img"></canvas>
    </div>
  </div>

  <script>
    const state = [];
    const trades = [];
    const STORAGE_KEY = 'winrate:strategies.v1';
    const AVAILABLE_PAIRS = ['EURUSD', 'TECH100', 'BTCUSD'];
    const EXPORT_FILENAME_JSON = 'winrate-backup.json';
    const EXPORT_FILENAME_CSV = 'winrate-trades.csv';

    function createId() {
      return Math.random().toString(36).slice(2) + Date.now().toString(36);
    }

    function formatWinrate(wins, losses) {
      const total = wins + losses;
      if (total === 0) return '-';
      return ((wins / total) * 100).toFixed(2) + '%';
    }

    function toISODateOnly(d = new Date()) {
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${y}-${m}-${day}`;
    }

    function dayName(dateStr) {
      const d = new Date(dateStr);
      if (Number.isNaN(d.getTime())) return '';
      return d.toLocaleDateString('nl-NL', { weekday: 'long' });
    }

    function saveState() {
      try {
        const payload = { version: 2, strategies: state, trades, pairs: AVAILABLE_PAIRS };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
      } catch (_) {
        // ignore storage errors (quota/unsupported)
      }
    }

    function loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        const parsed = JSON.parse(raw);
        state.length = 0;
        trades.length = 0;
        if (Array.isArray(parsed)) {
          // v1 compat: array van strategies
          for (const item of parsed) {
            const id = typeof item?.id === 'string' ? item.id : createId();
            const name = typeof item?.name === 'string' ? item.name : 'Onbekend';
            const wins = Math.max(0, Number.isFinite(+item?.wins) ? +item.wins : 0);
            const losses = Math.max(0, Number.isFinite(+item?.losses) ? +item.losses : 0);
            state.push({ id, name, wins, losses });
          }
        } else if (parsed && typeof parsed === 'object') {
          const strategies = Array.isArray(parsed.strategies) ? parsed.strategies : [];
          const savedTrades = Array.isArray(parsed.trades) ? parsed.trades : [];
          for (const item of strategies) {
            const id = typeof item?.id === 'string' ? item.id : createId();
            const name = typeof item?.name === 'string' ? item.name : 'Onbekend';
            const wins = Math.max(0, Number.isFinite(+item?.wins) ? +item.wins : 0);
            const losses = Math.max(0, Number.isFinite(+item?.losses) ? +item.losses : 0);
            state.push({ id, name, wins, losses });
          }
          for (const t of savedTrades) {
            const id = typeof t?.id === 'string' ? t.id : createId();
            const strategyId = typeof t?.strategyId === 'string' ? t.strategyId : '';
            const date = typeof t?.date === 'string' ? t.date : toISODateOnly();
            const pair = typeof t?.pair === 'string' ? t.pair : 'EURUSD';
            const result = t?.result === 'win' ? 'win' : 'loss';
            trades.push({ id, strategyId, date, pair, result });
          }
        }
      } catch (_) {
        // ignore parse/storage errors
      }
    }

    function commit() {
      saveState();
      render();
    }

    function addTrade({ strategyId, date, pair, side, result }) {
      const id = createId();
      const safeDate = date && !Number.isNaN(new Date(date).getTime()) ? date : toISODateOnly();
      const safePair = AVAILABLE_PAIRS.includes(pair) ? pair : AVAILABLE_PAIRS[0];
      const safeSide = side === 'sell' ? 'sell' : 'buy';
      trades.push({ id, strategyId, date: safeDate, pair: safePair, side: safeSide, result });
    }

    function removeTradesForStrategy(strategyId) {
      for (let i = trades.length - 1; i >= 0; i -= 1) {
        if (trades[i].strategyId === strategyId) trades.splice(i, 1);
      }
    }

    function removeSingleTrade(tradeId) {
      const idx = trades.findIndex(t => t.id === tradeId);
      if (idx === -1) return;
      const t = trades[idx];
      trades.splice(idx, 1);
      const stratIdx = state.findIndex(s => s.id === t.strategyId);
      if (stratIdx !== -1) {
        const s = state[stratIdx];
        if (t.result === 'win' && s.wins > 0) s.wins -= 1;
        if (t.result === 'loss' && s.losses > 0) s.losses -= 1;
      }
      commit();
    }

    function renderTrades() {
      const tbody = document.getElementById('tradesTbody');
      if (!tbody) return;
      const rows = trades
        .slice()
        .sort((a, b) => (a.date < b.date ? 1 : a.date > b.date ? -1 : 0))
        .slice(0, 100)
        .map(t => {
          const strat = state.find(s => s.id === t.strategyId);
          const stratName = strat ? strat.name : '(verwijderd)';
          return `
            <tr data-trade-id="${t.id}">
              <td>${t.date}</td>
              <td>${dayName(t.date)}</td>
              <td>${t.pair}</td>
              <td>${t.side === 'sell' ? 'Sell' : 'Buy'}</td>
              <td>${stratName}</td>
              <td class="num">${t.result === 'win' ? 'Win' : 'Loss'}</td>
              <td><button class="small danger" data-action="remove-trade">Verwijder</button></td>
            </tr>
          `;
        }).join('');
      tbody.innerHTML = rows || '<tr><td colspan="7" class="muted">Nog geen trades</td></tr>';
      renderTrendChart();
    }

    function downloadBlob(content, filename, type = 'application/octet-stream') {
      const blob = new Blob([content], { type });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function exportJson() {
      const payload = {
        version: 2,
        exportedAt: new Date().toISOString(),
        strategies: state,
        trades,
        pairs: AVAILABLE_PAIRS,
      };
      downloadBlob(JSON.stringify(payload, null, 2), EXPORT_FILENAME_JSON, 'application/json');
    }

    function csvEscape(val) {
      const s = String(val ?? '');
      if (/[",\n]/.test(s)) return '"' + s.replace(/"/g, '""') + '"';
      return s;
    }

    function exportCsv() {
      const header = ['date','weekday','pair','side','strategy','result'];
      const lines = [header.join(',')];
      const arr = trades.slice().sort((a,b) => a.date.localeCompare(b.date));
      for (const t of arr) {
        const strat = state.find(s => s.id === t.strategyId);
        const stratName = strat ? strat.name : '';
        const row = [
          t.date,
          dayName(t.date),
          t.pair,
          t.side || 'buy',
          stratName,
          t.result,
        ].map(csvEscape).join(',');
        lines.push(row);
      }
      downloadBlob(lines.join('\n'), EXPORT_FILENAME_CSV, 'text/csv');
    }

    function importJson(file) {
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const parsed = JSON.parse(String(reader.result));
          if (Array.isArray(parsed)) {
            // v1 array-only
            state.length = 0; trades.length = 0;
            for (const item of parsed) {
              const id = typeof item?.id === 'string' ? item.id : createId();
              const name = typeof item?.name === 'string' ? item.name : 'Onbekend';
              const wins = Math.max(0, Number.isFinite(+item?.wins) ? +item.wins : 0);
              const losses = Math.max(0, Number.isFinite(+item?.losses) ? +item.losses : 0);
              state.push({ id, name, wins, losses });
            }
          } else if (parsed && typeof parsed === 'object') {
            const strategies = Array.isArray(parsed.strategies) ? parsed.strategies : [];
            const savedTrades = Array.isArray(parsed.trades) ? parsed.trades : [];
            state.length = 0; trades.length = 0;
            for (const item of strategies) {
              const id = typeof item?.id === 'string' ? item.id : createId();
              const name = typeof item?.name === 'string' ? item.name : 'Onbekend';
              const wins = Math.max(0, Number.isFinite(+item?.wins) ? +item.wins : 0);
              const losses = Math.max(0, Number.isFinite(+item?.losses) ? +item.losses : 0);
              state.push({ id, name, wins, losses });
            }
            for (const t of savedTrades) {
              const id = typeof t?.id === 'string' ? t.id : createId();
              const strategyId = typeof t?.strategyId === 'string' ? t.strategyId : '';
              const date = typeof t?.date === 'string' ? t.date : toISODateOnly();
              const pair = typeof t?.pair === 'string' ? t.pair : 'EURUSD';
              const side = t?.side === 'sell' ? 'sell' : 'buy';
              const result = t?.result === 'win' ? 'win' : 'loss';
              trades.push({ id, strategyId, date, pair, side, result });
            }
          }
          commit();
          alert('Import succesvol.');
        } catch (err) {
          alert('Kon bestand niet importeren. Controleer het JSON-formaat.');
        }
      };
      reader.readAsText(file);
    }

    function render() {
      const tbody = document.getElementById('tbody');
      tbody.innerHTML = state.map(s => {
        const total = s.wins + s.losses;
        const winrate = formatWinrate(s.wins, s.losses);
        return `
          <tr data-id="${s.id}">
            <td>${s.name}</td>
            <td class="num">
              <input type="number" class="wins-input" min="0" value="${s.wins}" />
            </td>
            <td class="num">
              <input type="number" class="losses-input" min="0" value="${s.losses}" />
            </td>
            <td class="num hide-sm">${total}</td>
            <td class="num">${winrate}</td>
            <td>
              <select class="pair-select">
                ${AVAILABLE_PAIRS.map(p => `<option value="${p}">${p}</option>`).join('')}
              </select>
            </td>
            <td>
              <select class="side-select">
                <option value="buy">Buy</option>
                <option value="sell">Sell</option>
              </select>
            </td>
            <td>
              <input type="date" class="date-input" value="${toISODateOnly()}" />
            </td>
            <td class="actions">
              <button class="small secondary" data-action="inc-win">+ Win</button>
              <button class="small secondary" data-action="inc-loss">+ Loss</button>
              <button class="small danger" data-action="remove">Verwijder</button>
            </td>
          </tr>
        `;
      }).join('');

      const totalWins = state.reduce((a, s) => a + s.wins, 0);
      const totalLosses = state.reduce((a, s) => a + s.losses, 0);
      const totalTrades = totalWins + totalLosses;

      document.getElementById('totalWins').textContent = totalWins;
      document.getElementById('totalLosses').textContent = totalLosses;
      document.getElementById('totalTrades').textContent = totalTrades;
      document.getElementById('totalWinrate').textContent = formatWinrate(totalWins, totalLosses);
      renderTrades();
    }

    function addStrategy(name) {
      state.push({ id: createId(), name, wins: 0, losses: 0 });
      commit();
    }

    function updateStrategy(id, updates) {
      const idx = state.findIndex(s => s.id === id);
      if (idx === -1) return;
      state[idx] = { ...state[idx], ...updates };
      commit();
    }

    function removeStrategy(id) {
      const idx = state.findIndex(s => s.id === id);
      if (idx === -1) return;
      state.splice(idx, 1);
      commit();
    }

    document.getElementById('addForm').addEventListener('submit', (e) => {
      e.preventDefault();
      const input = document.getElementById('strategyName');
      const name = input.value.trim();
      if (!name) return;
      addStrategy(name);
      input.value = '';
      input.focus();
    });

    document.getElementById('tbody').addEventListener('click', (e) => {
      const btn = e.target.closest('button[data-action]');
      if (!btn) return;
      const row = e.target.closest('tr[data-id]');
      const id = row?.dataset.id;
      const strategy = state.find(s => s.id === id);
      if (!strategy) return;

      const action = btn.dataset.action;
      const pairSelect = row.querySelector('.pair-select');
      const sideSelect = row.querySelector('.side-select');
      const dateInput = row.querySelector('.date-input');
      const selectedPair = pairSelect?.value || AVAILABLE_PAIRS[0];
      const selectedSide = sideSelect?.value || 'buy';
      const selectedDate = dateInput?.value || toISODateOnly();

      if (action === 'inc-win') {
        addTrade({ strategyId: id, pair: selectedPair, side: selectedSide, date: selectedDate, result: 'win' });
        updateStrategy(id, { wins: strategy.wins + 1 });
      } else if (action === 'inc-loss') {
        addTrade({ strategyId: id, pair: selectedPair, side: selectedSide, date: selectedDate, result: 'loss' });
        updateStrategy(id, { losses: strategy.losses + 1 });
      } else if (action === 'remove') {
        removeTradesForStrategy(id);
        removeStrategy(id);
      }
    });

    document.getElementById('tbody').addEventListener('input', (e) => {
      const input = e.target;
      const row = input.closest('tr[data-id]');
      if (!row) return;
      const id = row.dataset.id;
      const strategy = state.find(s => s.id === id);
      if (!strategy) return;

      if (input.classList.contains('wins-input')) {
        const wins = Math.max(0, parseInt(input.value, 10) || 0);
        updateStrategy(id, { wins });
      } else if (input.classList.contains('losses-input')) {
        const losses = Math.max(0, parseInt(input.value, 10) || 0);
        updateStrategy(id, { losses });
      }
    });

    function hydrateAndRender() {
      loadState();
      render();
    }

    // Sync updates tussen tabs/vensters
    window.addEventListener('storage', (e) => {
      if (e.key === STORAGE_KEY) {
        loadState();
        render();
      }
    });

    hydrateAndRender();

    // Eenvoudige lijn-diagram (zonder externe libs)
    function renderTrendChart() {
      const canvas = document.getElementById('trendChart');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const W = canvas.width;
      const H = canvas.height;

      // Dataset: cumulatief per datum
      const sorted = trades.slice().sort((a, b) => (a.date < b.date ? -1 : a.date > b.date ? 1 : 0));
      let cumulative = 0;
      const pointsData = sorted.map(t => {
        cumulative += t.result === 'win' ? 1 : -1;
        return { date: t.date, value: cumulative };
      });

      // Basis canvas
      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--surface') || '#fff';
      ctx.fillRect(0, 0, W, H);

      const margin = { top: 20, right: 20, bottom: 28, left: 46 };
      const innerW = W - margin.left - margin.right;
      const innerH = H - margin.top - margin.bottom;

      const values = pointsData.length ? pointsData.map(p => p.value) : [0];
      const minY = Math.min(0, ...values);
      const maxY = Math.max(0, ...values);
      const yRange = maxY - minY || 1;

      const dates = pointsData.length ? pointsData.map(p => p.date) : [toISODateOnly()];
      const xCount = Math.max(1, dates.length - 1);
      const xAt = (i) => margin.left + (i / Math.max(1, xCount)) * innerW;
      const yAt = (v) => margin.top + (1 - (v - minY) / yRange) * innerH;

      const pts = pointsData.map((p, i) => ({ x: xAt(i), y: yAt(p.value) }));

      // Gridlijnen (0-lijn + zachte horizontale lijnen)
      const border = (getComputedStyle(document.documentElement).getPropertyValue('--border') || '#e5e7eb').trim();
      ctx.strokeStyle = border;
      ctx.lineWidth = 1;
      ctx.beginPath();
      const yZero = yAt(0);
      ctx.moveTo(margin.left, yZero);
      ctx.lineTo(W - margin.right, yZero);
      ctx.stroke();
      // extra grid (quartiles)
      const gridSteps = 3;
      for (let i = 1; i <= gridSteps; i += 1) {
        const gy = margin.top + (innerH / (gridSteps + 1)) * i;
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.moveTo(margin.left, gy);
        ctx.lineTo(W - margin.right, gy);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }

      // Lijn + area (met smoothing en animatie)
      const primary = (getComputedStyle(document.documentElement).getPropertyValue('--primary') || '#2563eb').trim();
      const gradFill = ctx.createLinearGradient(0, margin.top, 0, margin.top + innerH);
      gradFill.addColorStop(0, primary + '33');
      gradFill.addColorStop(1, primary + '00');

      function drawSmoothedPath(ptsSubset) {
        if (ptsSubset.length === 0) return;
        if (ptsSubset.length === 1) {
          ctx.beginPath();
          ctx.arc(ptsSubset[0].x, ptsSubset[0].y, 3, 0, Math.PI * 2);
          ctx.fill();
          return;
        }
        ctx.beginPath();
        ctx.moveTo(ptsSubset[0].x, ptsSubset[0].y);
        for (let i = 0; i < ptsSubset.length - 1; i += 1) {
          const p0 = ptsSubset[i];
          const p1 = ptsSubset[i + 1];
          const mx = (p0.x + p1.x) / 2;
          const my = (p0.y + p1.y) / 2;
          ctx.quadraticCurveTo(p0.x, p0.y, mx, my);
        }
        // laatste stuk naar eindpunt
        const last = ptsSubset[ptsSubset.length - 1];
        const prev = ptsSubset[ptsSubset.length - 2];
        if (prev) ctx.quadraticCurveTo(prev.x, prev.y, last.x, last.y);
      }

      function drawChart(tProgress) {
        // slice punten tot progress
        if (pts.length === 0) return;
        const totalSeg = Math.max(1, pts.length - 1);
        const segFloat = Math.min(1, Math.max(0, tProgress)) * totalSeg;
        const full = Math.floor(segFloat);
        const frac = segFloat - full;
        const subset = pts.slice(0, full + 1);
        if (full < pts.length - 1) {
          const a = pts[full];
          const b = pts[full + 1];
          subset.push({ x: a.x + (b.x - a.x) * frac, y: a.y + (b.y - a.y) * frac });
        }

        // Area fill
        ctx.save();
        ctx.fillStyle = gradFill;
        ctx.beginPath();
        ctx.moveTo(subset[0].x, yZero);
        // smooth path along subset
        let tmpPts = subset.slice();
        if (tmpPts.length >= 2) {
          ctx.lineTo(tmpPts[0].x, tmpPts[0].y);
          for (let i = 0; i < tmpPts.length - 1; i += 1) {
            const p0 = tmpPts[i];
            const p1 = tmpPts[i + 1];
            const mx = (p0.x + p1.x) / 2;
            const my = (p0.y + p1.y) / 2;
            ctx.quadraticCurveTo(p0.x, p0.y, mx, my);
          }
          const last = tmpPts[tmpPts.length - 1];
          const prev = tmpPts[tmpPts.length - 2];
          if (prev) ctx.quadraticCurveTo(prev.x, prev.y, last.x, last.y);
        }
        const end = subset[subset.length - 1];
        ctx.lineTo(end.x, yZero);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        // Stroke line
        ctx.save();
        ctx.lineWidth = 2.5;
        ctx.strokeStyle = primary;
        ctx.shadowColor = primary + '55';
        ctx.shadowBlur = 6;
        drawSmoothedPath(subset);
        ctx.stroke();
        ctx.restore();

        // Points
        ctx.fillStyle = primary;
        subset.forEach(p => {
          ctx.beginPath();
          ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
          ctx.fill();
        });

        // Y-labels (min/0/max)
        const textColor = (getComputedStyle(document.documentElement).getPropertyValue('--muted') || '#6b7280').trim();
        ctx.fillStyle = textColor;
        ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        ctx.fillText(String(maxY), margin.left - 8, yAt(maxY));
        ctx.fillText('0', margin.left - 8, yZero);
        ctx.fillText(String(minY), margin.left - 8, yAt(minY));

        // X-labels (eerste/laatste)
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        const firstX = pts[0].x;
        const lastX = pts[pts.length - 1].x;
        const firstDate = dates[0];
        const lastDate = dates[dates.length - 1];
        ctx.fillText(firstDate, firstX, H - margin.bottom + 6);
        if (lastX - firstX > 80) ctx.fillText(lastDate, lastX, H - margin.bottom + 6);
      }

      const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      if (prefersReduced || pts.length <= 1) {
        drawChart(1);
      } else {
        const start = performance.now();
        const duration = 650;
        function step(now) {
          const t = Math.min(1, (now - start) / duration);
          // redraw background and grid each frame
          ctx.clearRect(0, 0, W, H);
          ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--surface') || '#fff';
          ctx.fillRect(0, 0, W, H);
          // redraw grid
          ctx.strokeStyle = border;
          ctx.lineWidth = 1;
          ctx.beginPath();
          const yZero2 = yZero;
          ctx.moveTo(margin.left, yZero2);
          ctx.lineTo(W - margin.right, yZero2);
          ctx.stroke();
          const gridSteps2 = 3;
          for (let i = 1; i <= gridSteps2; i += 1) {
            const gy = margin.top + (innerH / (gridSteps2 + 1)) * i;
            ctx.globalAlpha = 0.5;
            ctx.beginPath();
            ctx.moveTo(margin.left, gy);
            ctx.lineTo(W - margin.right, gy);
            ctx.stroke();
            ctx.globalAlpha = 1;
          }
          drawChart(t);
          if (t < 1) requestAnimationFrame(step);
        }
        requestAnimationFrame(step);
      }
    }

    // Toolbar events
    document.getElementById('btnExportJson').addEventListener('click', exportJson);
    document.getElementById('btnExportCsv').addEventListener('click', exportCsv);
    const importPane = document.getElementById('importPane');
    const importText = document.getElementById('importText');
    document.getElementById('btnToggleImport').addEventListener('click', () => {
      importPane.classList.toggle('open');
      if (importPane.classList.contains('open')) importText.focus();
    });
    document.getElementById('btnCancelImport').addEventListener('click', () => {
      importPane.classList.remove('open');
      importText.value = '';
    });
    document.getElementById('btnImportText').addEventListener('click', () => {
      const raw = importText.value.trim();
      if (!raw) return;
      try {
        const parsed = JSON.parse(raw);
        if (Array.isArray(parsed)) {
          state.length = 0; trades.length = 0;
          for (const item of parsed) {
            const id = typeof item?.id === 'string' ? item.id : createId();
            const name = typeof item?.name === 'string' ? item.name : 'Onbekend';
            const wins = Math.max(0, Number.isFinite(+item?.wins) ? +item.wins : 0);
            const losses = Math.max(0, Number.isFinite(+item?.losses) ? +item.losses : 0);
            state.push({ id, name, wins, losses });
          }
        } else if (parsed && typeof parsed === 'object') {
          const strategies = Array.isArray(parsed.strategies) ? parsed.strategies : [];
          const savedTrades = Array.isArray(parsed.trades) ? parsed.trades : [];
          state.length = 0; trades.length = 0;
          for (const item of strategies) {
            const id = typeof item?.id === 'string' ? item.id : createId();
            const name = typeof item?.name === 'string' ? item.name : 'Onbekend';
            const wins = Math.max(0, Number.isFinite(+item?.wins) ? +item.wins : 0);
            const losses = Math.max(0, Number.isFinite(+item?.losses) ? +item.losses : 0);
            state.push({ id, name, wins, losses });
          }
          for (const t of savedTrades) {
            const id = typeof t?.id === 'string' ? t.id : createId();
            const strategyId = typeof t?.strategyId === 'string' ? t.strategyId : '';
            const date = typeof t?.date === 'string' ? t.date : toISODateOnly();
            const pair = typeof t?.pair === 'string' ? t.pair : 'EURUSD';
            const side = t?.side === 'sell' ? 'sell' : 'buy';
            const result = t?.result === 'win' ? 'win' : 'loss';
            trades.push({ id, strategyId, date, pair, side, result });
          }
        }
        commit();
        importPane.classList.remove('open');
        importText.value = '';
        alert('Import succesvol.');
      } catch (err) {
        alert('Kon JSON niet parsen. Plak geldige JSON.');
      }
    });

    document.getElementById('btnEmail').addEventListener('click', () => {
      const totalWins = state.reduce((a, s) => a + s.wins, 0);
      const totalLosses = state.reduce((a, s) => a + s.losses, 0);
      const totalTrades = totalWins + totalLosses;
      const winrate = totalTrades ? ((totalWins/totalTrades)*100).toFixed(2) + '%' : '-';
      const to = 'satnam43359@gmail.com';

      // Geen automatische downloads meer bij versturen

      // Volledige JSON als e-mail body
      const payload = {
        version: 2,
        exportedAt: new Date().toISOString(),
        totals: { wins: totalWins, losses: totalLosses, trades: totalTrades, winrate },
        strategies: state,
        trades,
        pairs: AVAILABLE_PAIRS,
      };
      const subject = encodeURIComponent('Winrate backup (JSON)');
      const body = encodeURIComponent(JSON.stringify(payload));
      window.location.href = `mailto:${to}?subject=${subject}&body=${body}`;
    });

    // Verwijderen van enkele trade via event delegation
    document.querySelector('[aria-label="Trade log"]').addEventListener('click', (e) => {
      const btn = e.target.closest('button[data-action="remove-trade"]');
      if (!btn) return;
      const row = btn.closest('tr[data-trade-id]');
      const tradeId = row?.getAttribute('data-trade-id');
      if (!tradeId) return;
      removeSingleTrade(tradeId);
    });
  </script>
</body>
</html>

